{"version":3,"sources":["node_modules/eventemitter2/lib/eventemitter2.js","../rbd/pnpm-volume/8804483f-7435-434d-ab8d-d8d811696a6a/node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js","node_modules/performance-now/lib/performance-now.js","node_modules/inherits/inherits_browser.js","node_modules/raf/index.js","node_modules/gameloop/index.js","node_modules/gameloop-canvas/index.js","node_modules/isarray/index.js","node_modules/crtrdg-gameloop/index.js","index.js"],"names":["process","module","exports","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","Error","defaultClearTimeout","setTimeout","e","clearTimeout","runTimeout","fun","call","runClearTimeout","marker","queue","draining","currentQueue","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","nextTick","args","Array","arguments","i","push","Item","array","prototype","apply","title","env","argv","version","versions","noop","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","game","canvas","height","width","tileset","Image","src","ctx","dt","fillStyle","fillRect","drawImage","start"],"mappings":"AQAA,AFAA,ADAA,AFAA,AIAA;ANAA,AOCA,ARDA,AMCA,ADAA,AFAA,AIAA,ALDA,AEAA;AHCA,AQDA,ADEA,ARDA,AMCA,ADAA,AFAA,AIAA,ALDA,AEAA,IHAIA,OAAO,GAAGC,MAAM,CAACC,OAAP,GAAiB,EAA/B,EAEA;AACA,AODA,ARDA,AMCA,ADAA,AFAA,AIAA,ALDA,AEAA;AHGA,AODA,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA;AHGA,AODA,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA;AKFA,ADIA,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA,IKHMyD,IAAI,GAAG,8BAAb;ARMA,AQJAA,ADGA,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA,IHEIxD,AQJA,CAACyD,MAAL,CAAYC,MAAZ,ERIA,CQJqB,GAArB;ARKA,AQJAF,ADGA,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA,IHEIvD,AQJA,CAACwD,MAAL,CAAYE,KAAZ,GAAoB,ERIpB,CQJA;AAEA,ADEA,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA,IKDMC,OAAO,GAAG,IAAIC,KAAJ,CAAU,GAAV,EAAe,GAAf,CAAhB,EAAqC;ARIrC,AODA,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA,SHES3D,gBAAT,GAA4B;AACxB,AQJJ0D,ADGA,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA,OKFO,CRIG,AQJFE,GAAR,CRIc3D,EQJA,GRIJ,CAAU,iCAAV,CAAN,wEQJJ,EAGA;AREC,AODD,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA;AKIAqD,ADFA,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA,IKGI,CAAChB,EAAL,CAAQ,MAAR,EAAgB,UAAUuB,GAAV,EAAeC,EAAf,EAAmB;ARDnC,AQEE,ADFF,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA,SHCS5D,mBAAT,GAAgC;AAC5B,AQEF2D,ADFF,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA,EKGEA,GAAG,CAACE,ERFI,IAAI9D,GQEZ,ERFQ,CAAU,AQEF,MAAhB,6BRFQ,CAAN;AACH,AQEC4D,ADFF,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA,EKGEA,GAAG,CAACG,QAAJ,CAAa,CAAb,EAAgB,CAAhB,EAAmBH,GAAG,CAACN,MAAJ,CAAWE,KAA9B,EAAqCI,GAAG,CAACN,MAAJ,CAAWC,MAAhD;AACAK,ADFF,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA,EKGEA,GAAG,CAACI,SAAJ,CAAcP,OAAd,EAAuB,EAAvB,EAA2B,EAA3B,EAA+B,EAA/B,EAAmC,EAAnC,EAAuC,CAAvC,EAA0C,CAA1C,EAA6C,EAA7C,EAAiD,EAAjD;ARFD,AQGA,ADFD,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA,CKFA,YREa;AACT,AQKJJ,ADJA,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA,IKKI,CAACY,CRLG,IQKR;ARJQ,AOCR,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA,QHAY,OAAO/D,UAAP,KAAsB,UAA1B,EAAsC;AAClCL,AOCZ,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA,MHAYA,gBAAgB,GAAGK,UAAnB;AACH,AOCT,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA,KHFQ,MAEO;AACHL,AOCZ,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA,MHAYA,gBAAgB,GAAGE,gBAAnB;AACH,AOCT,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA;AHCK,AOCL,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA,GHNI,CAME,OAAOI,CAAP,EAAU;AACRN,AOCR,ARDA,AMCA,ADAA,AFAA,ADDA,AEAA,IHAQA,gBAAgB,GAAGE,gBAAnB;AACH,AOCL,ARDA,AKCA,AFAA,ADDA,AEAA;AIEA,ARDA,AKCA,AHDA,AEAA;AHAI,AOEJ,ARDA,AKCA,AHDA,AEAA,MHDQ;AACA,AOER,ARDA,AKCA,AHDA,AEAA,QHDY,OAAOK,YAAP,KAAwB,UAA5B,EAAwC;AACpCN,AOEZ,ARDA,AKCA,AHDA,AEAA,MHDYA,kBAAkB,GAAGM,YAArB;AACH,AOET,ARDA,AKCA,AHDA,AEAA,KHHQ,MAEO;AACHN,AOEZ,ARDA,AKCA,AHDA,AEAA,MHDYA,kBAAkB,GAAGG,mBAArB;AACH,AOET,ARDA,AKCA,ADDA;AHAK,AOEL,ARDA,AKCA,ADDA,GHPI,CAME,OAAOE,CAAP,EAAU;AACRL,AOER,ARDA,AKCA,ADDA,IHDQA,kBAAkB,GAAGG,mBAArB;AACH,AOEL,ARDA,AKCA,ADDA;AHAC,AOED,ARDA,AKCA,ADDA,CHpBC,GAAD;AOsBA,ARDA,AKCA,ADDA;AHDA,AOGA,ARDA,AKCA,ADDA,SHFSI,UAAT,CAAoBC,GAApB,EAAyB;AACrB,AOGJ,ARDA,AKCA,ADDA,MHFQT,gBAAgB,KAAKK,UAAzB,EAAqC;AACjC,AOGR,ARDA,AKCA,ADDA;AHDQ,AOGR,ARDA,AKCA,ADDA,WHFeA,UAAU,CAACI,GAAD,EAAM,CAAN,CAAjB;AACH,AOGL,ARDA,AKCA,ADDA,GHNyB,CAKrB;AOGJ,ARDA,AKCA,ADDA;AIEA,ARDA,AKCA,ADDA;AHFI,AOIJ,ARDA,AKCA,ADDA,MHHQ,CAACT,gBAAgB,KAAKE,gBAArB,IAAyC,CAACF,gBAA3C,KAAgEK,UAApE,EAAgF;AAC5EL,AOIR,ARDA,AKCA,ADDA,IHHQA,gBAAgB,GAAGK,UAAnB;AACA,AOIR,ARDA,AKCA,ADDA,WHHeA,UAAU,CAACI,GAAD,EAAM,CAAN,CAAjB;AACH,AOIL,ARDA,AKCA,ADDA;AIEA,ARDA,AKCA,ADDA;AHHI,AOKJ,ARDA,AKCA,ADDA,MHJQ;AACA,AOKR,ARDA,AKCA,ADDA;AHHQ,AOKR,ARDA,AKCA,ADDA,WHJeT,gBAAgB,CAACS,GAAD,EAAM,CAAN,CAAvB;AACH,AOKL,ARDA,AKCA,ADDA,GHPI,CAGE,OAAMH,CAAN,EAAQ;AACN,AOKR,ARDA,AKCA,ADDA,QHJY;AACA,AOKZ,ARDA,AKCA,ADDA;AHHY,AOKZ,ARDA,AKCA,ADDA,aHJmBN,gBAAgB,CAACU,IAAjB,CAAsB,IAAtB,EAA4BD,GAA5B,EAAiC,CAAjC,CAAP;AACH,AOKT,ARDA,AKCA,ADDA,KHPQ,CAGE,OAAMH,CAAN,EAAQ;AACN,AOKZ,ARDA,AKCA,ADDA;AHHY,AOKZ,ARDA,AKCA,ADDA,aHJmBN,gBAAgB,CAACU,IAAjB,CAAsB,IAAtB,EAA4BD,GAA5B,EAAiC,CAAjC,CAAP;AACH,AOKT,ARDA,AKCA,ADDA;AHHK,AOKL,ARDA,AKCA,ADDA;AHDC,AOGD,ARDA,AKCA,ADDA;AIEA,ARDA,AKCA,ADDA;AHFA,AOIA,ARDA,AKCA,ADDA,SHHSE,eAAT,CAAyBC,MAAzB,EAAiC;AAC7B,AOIJ,ARDA,AKCA,ADDA,MHHQX,kBAAkB,KAAKM,YAA3B,EAAyC;AACrC,AOIR,ARDA,AKCA,ADDA;AHFQ,AOIR,ARDA,AKCA,ADDA,WHHeA,YAAY,CAACK,MAAD,CAAnB;AACH,AOIL,ARDA,AKCA,ADDA,GHPiC,CAK7B;AOIJ,ARDA,AKCA,ADDA;AIEA,ARDA,AKCA,ADDA;AHHI,AOKJ,ARDA,AKCA,ADDA,MHJQ,CAACX,kBAAkB,KAAKG,mBAAvB,IAA8C,CAACH,kBAAhD,KAAuEM,YAA3E,EAAyF;AACrFN,AOKR,ARDA,AKCA,ADDA,IHJQA,kBAAkB,GAAGM,YAArB;AACA,AOKR,ARDA,AKCA,ADDA,WHJeA,YAAY,CAACK,MAAD,CAAnB;AACH,AOKL,ARDA,AKCA,ADDA;AIEA,ARDA,AKCA;AJLI,AOMJ,ARDA,AKCA,MJNQ;AACA,AOMR,ARDA,AKCA;AJLQ,AOMR,ARDA,AKCA,WJNeX,kBAAkB,CAACW,MAAD,CAAzB;AACH,AOML,ARDA,AKCA,GJTI,CAGE,OAAON,CAAP,EAAS;AACP,AOMR,ARDA,AKCA,QJNY;AACA,AOMZ,ARDA,AKCA;AJLY,AOMZ,ARDA,AKCA,aJNmBL,kBAAkB,CAACS,IAAnB,CAAwB,IAAxB,EAA8BE,MAA9B,CAAP;AACH,AOMT,ARDA,AKCA,KJTQ,CAGE,OAAON,CAAP,EAAS;AACP,AOMZ,ARDA,AKCA;AJLY,AOMZ,ARDA,AKCA;AJLY,AOMZ,ARDA,AKCA,aJNmBL,kBAAkB,CAACS,IAAnB,CAAwB,IAAxB,EAA8BE,MAA9B,CAAP;AACH,AOMT,ARDA,AKCA;AJLK,AOML,ARDA,AKCA;AJFC,AOGD,ARDA,AKCA;AGCA,ARDA,AKCA;AJHA,AOIA,ARDA,AKCA,IJJIC,KAAK,GAAG,EAAZ;AACA,AOIA,ARDA,AKCA,IJJIC,QAAQ,GAAG,KAAf;AACA,AOIA,ARDA,AKCA,IJJIC,YAAJ;AACA,AOIA,ARDA,AKCA,IJJIC,UAAU,GAAG,CAAC,CAAlB;AOKA,ARDA,AKCA;AJHA,AOIA,ARDA,AKCA,SJJSC,eAAT,GAA2B;AACvB,AOIJ,ARDA,AKCA,MJJQ,CAACH,QAAD,IAAa,CAACC,YAAlB,EAAgC;AAC5B,AOIR,ARDA,AKCA;AJHK,AOIL,ARDA,AKCA;AGCA,ARDA,AKCA;AJJID,AOKJ,ARDA,AKCA,EJLIA,QAAQ,GAAG,KAAX;AOMJ,ARDA,AKCA;AJLI,AOMJ,ARDA,AKCA,MJNQC,YAAY,CAACG,MAAjB,EAAyB;AACrBL,AOMR,ARDA,AKCA,IJNQA,KAAK,GAAGE,YAAY,CAACI,MAAb,CAAoBN,KAApB,CAAR;AACH,AOML,ARDA,AKCA,GJRI,MAEO;AACHG,AOMR,ARDA,AKCA,IJNQA,UAAU,GAAG,CAAC,CAAd;AACH,AOML,ARDA,AKCA;AGCA,ARDA,AKCA;AJNI,AOOJ,ARDA,AKCA,MJPQH,KAAK,CAACK,MAAV,EAAkB;AACdE,AOOR,ARDA,AKCA,IJPQA,UAAU;AACb,AOOL,ARDA,AKCA;AJNC,AOOD,ARDA,AKCA;AGCA,ARDA,AKCA;AJNA,AOOA,ARDA,AKCA,SJPSA,UAAT,GAAsB;AAClB,AOOJ,ARDA,AKCA,MJPQN,QAAJ,EAAc;AACV,AOOR,ARDA,AKCA;AJNK,AOOL,ARDA,AKCA;AGCA,ARDA,AKCA;AJPI,AOQJ,ARDA,AKCA,MJRQO,OAAO,GAAGb,UAAU,CAACS,eAAD,CAAxB;AACAH,AOQJ,ARDA,AKCA,EJRIA,QAAQ,GAAG,IAAX;AAEA,AOOJ,ARDA,AKCA,MJPQQ,GAAG,GAAGT,KAAK,CAACK,MAAhB;AOQJ,ARDA,AKCA;AJPI,AOQJ,ARDA,AKCA,SJRUI,GAAN,EAAW;AACPP,AOQR,ARDA,AKCA,IJRQA,YAAY,GAAGF,KAAf;AACAA,AOQR,ARDA,AKCA,IJRQA,KAAK,GAAG,EAAR;AOSR,ARDA,AKCA;AJRQ,AOSR,ARDA,AKCA,WJTe,EAAEG,UAAF,GAAeM,GAAtB,EAA2B;AACvB,AOSZ,ARDA,AKCA,UJTgBP,YAAJ,EAAkB;AACdA,AOShB,ARDA,AKCA,QJTgBA,YAAY,CAACC,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JlBO,CAACuD,GAAR,GAAc,YAAY;AAAE,ADkB5B,AKCA,SJnBmC,GAAP;AAAY,ADmBxC,AKCA,CJpBA;ADoBA,AKCA;AJpBAvD,ADoBA,AKCA,OJrBO,CAACwD,KAAR,GAAgB,UAAUC,GAAV,EAAe;AAC3B,ADoBJ,AKCA,QJrBU,IAAInD,KAAJ,CAAU,gCAAV,CAAN;AACH,ADoBD,AKCA,CJvBA;ADuBA,AKCA;AJrBAN,ADqBA,OCrBO,CAAC0D,KAAR,GAAgB,YAAW;AAAE,ADsB7B,SCtBoC,CAAP;AAAW,ADuBxC,CCvBA;ADwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.e31bb0bc.js","sourceRoot":"..","sourcesContent":["/*!\r\n * EventEmitter2\r\n * https://github.com/hij1nx/EventEmitter2\r\n *\r\n * Copyright (c) 2013 hij1nx\r\n * Licensed under the MIT license.\r\n */\r\n;!function(undefined) {\r\n\r\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\r\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\r\n  };\r\n  var defaultMaxListeners = 10;\r\n\r\n  function init() {\r\n    this._events = {};\r\n    if (this._conf) {\r\n      configure.call(this, this._conf);\r\n    }\r\n  }\r\n\r\n  function configure(conf) {\r\n    if (conf) {\r\n      this._conf = conf;\r\n\r\n      conf.delimiter && (this.delimiter = conf.delimiter);\r\n      this._events.maxListeners = conf.maxListeners !== undefined ? conf.maxListeners : defaultMaxListeners;\r\n      conf.wildcard && (this.wildcard = conf.wildcard);\r\n      conf.newListener && (this.newListener = conf.newListener);\r\n      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);\r\n\r\n      if (this.wildcard) {\r\n        this.listenerTree = {};\r\n      }\r\n    } else {\r\n      this._events.maxListeners = defaultMaxListeners;\r\n    }\r\n  }\r\n\r\n  function logPossibleMemoryLeak(count, eventName) {\r\n    var errorMsg = '(node) warning: possible EventEmitter memory ' +\r\n        'leak detected. %d listeners added. ' +\r\n        'Use emitter.setMaxListeners() to increase limit.';\r\n\r\n    if(this.verboseMemoryLeak){\r\n      errorMsg += ' Event name: %s.';\r\n      console.error(errorMsg, count, eventName);\r\n    } else {\r\n      console.error(errorMsg, count);\r\n    }\r\n\r\n    if (console.trace){\r\n      console.trace();\r\n    }\r\n  }\r\n\r\n  function EventEmitter(conf) {\r\n    this._events = {};\r\n    this.newListener = false;\r\n    this.verboseMemoryLeak = false;\r\n    configure.call(this, conf);\r\n  }\r\n  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\r\n\r\n  //\r\n  // Attention, function return type now is array, always !\r\n  // It has zero elements if no any matches found and one or more\r\n  // elements (leafs) if there are matches\r\n  //\r\n  function searchListenerTree(handlers, type, tree, i) {\r\n    if (!tree) {\r\n      return [];\r\n    }\r\n    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\r\n        typeLength = type.length, currentType = type[i], nextType = type[i+1];\r\n    if (i === typeLength && tree._listeners) {\r\n      //\r\n      // If at the end of the event(s) list and the tree has listeners\r\n      // invoke those listeners.\r\n      //\r\n      if (typeof tree._listeners === 'function') {\r\n        handlers && handlers.push(tree._listeners);\r\n        return [tree];\r\n      } else {\r\n        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\r\n          handlers && handlers.push(tree._listeners[leaf]);\r\n        }\r\n        return [tree];\r\n      }\r\n    }\r\n\r\n    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\r\n      //\r\n      // If the event emitted is '*' at this part\r\n      // or there is a concrete match at this patch\r\n      //\r\n      if (currentType === '*') {\r\n        for (branch in tree) {\r\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\r\n            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\r\n          }\r\n        }\r\n        return listeners;\r\n      } else if(currentType === '**') {\r\n        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\r\n        if(endReached && tree._listeners) {\r\n          // The next element has a _listeners, add it to the handlers.\r\n          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\r\n        }\r\n\r\n        for (branch in tree) {\r\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\r\n            if(branch === '*' || branch === '**') {\r\n              if(tree[branch]._listeners && !endReached) {\r\n                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\r\n              }\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\r\n            } else if(branch === nextType) {\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\r\n            } else {\r\n              // No match on this one, shift into the tree but not in the type array.\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\r\n            }\r\n          }\r\n        }\r\n        return listeners;\r\n      }\r\n\r\n      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\r\n    }\r\n\r\n    xTree = tree['*'];\r\n    if (xTree) {\r\n      //\r\n      // If the listener tree will allow any match for this part,\r\n      // then recursively explore all branches of the tree\r\n      //\r\n      searchListenerTree(handlers, type, xTree, i+1);\r\n    }\r\n\r\n    xxTree = tree['**'];\r\n    if(xxTree) {\r\n      if(i < typeLength) {\r\n        if(xxTree._listeners) {\r\n          // If we have a listener on a '**', it will catch all, so add its handler.\r\n          searchListenerTree(handlers, type, xxTree, typeLength);\r\n        }\r\n\r\n        // Build arrays of matching next branches and others.\r\n        for(branch in xxTree) {\r\n          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\r\n            if(branch === nextType) {\r\n              // We know the next element will match, so jump twice.\r\n              searchListenerTree(handlers, type, xxTree[branch], i+2);\r\n            } else if(branch === currentType) {\r\n              // Current node matches, move into the tree.\r\n              searchListenerTree(handlers, type, xxTree[branch], i+1);\r\n            } else {\r\n              isolatedBranch = {};\r\n              isolatedBranch[branch] = xxTree[branch];\r\n              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\r\n            }\r\n          }\r\n        }\r\n      } else if(xxTree._listeners) {\r\n        // We have reached the end and still on a '**'\r\n        searchListenerTree(handlers, type, xxTree, typeLength);\r\n      } else if(xxTree['*'] && xxTree['*']._listeners) {\r\n        searchListenerTree(handlers, type, xxTree['*'], typeLength);\r\n      }\r\n    }\r\n\r\n    return listeners;\r\n  }\r\n\r\n  function growListenerTree(type, listener) {\r\n\r\n    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n\r\n    //\r\n    // Looks for two consecutive '**', if so, don't add the event at all.\r\n    //\r\n    for(var i = 0, len = type.length; i+1 < len; i++) {\r\n      if(type[i] === '**' && type[i+1] === '**') {\r\n        return;\r\n      }\r\n    }\r\n\r\n    var tree = this.listenerTree;\r\n    var name = type.shift();\r\n\r\n    while (name !== undefined) {\r\n\r\n      if (!tree[name]) {\r\n        tree[name] = {};\r\n      }\r\n\r\n      tree = tree[name];\r\n\r\n      if (type.length === 0) {\r\n\r\n        if (!tree._listeners) {\r\n          tree._listeners = listener;\r\n        }\r\n        else {\r\n          if (typeof tree._listeners === 'function') {\r\n            tree._listeners = [tree._listeners];\r\n          }\r\n\r\n          tree._listeners.push(listener);\r\n\r\n          if (\r\n            !tree._listeners.warned &&\r\n            this._events.maxListeners > 0 &&\r\n            tree._listeners.length > this._events.maxListeners\r\n          ) {\r\n            tree._listeners.warned = true;\r\n            logPossibleMemoryLeak.call(this, tree._listeners.length, name);\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      name = type.shift();\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // By default EventEmitters will print a warning if more than\r\n  // 10 listeners are added to it. This is a useful default which\r\n  // helps finding memory leaks.\r\n  //\r\n  // Obviously not all Emitters should be limited to 10. This function allows\r\n  // that to be increased. Set to zero for unlimited.\r\n\r\n  EventEmitter.prototype.delimiter = '.';\r\n\r\n  EventEmitter.prototype.setMaxListeners = function(n) {\r\n    if (n !== undefined) {\r\n      this._events || init.call(this);\r\n      this._events.maxListeners = n;\r\n      if (!this._conf) this._conf = {};\r\n      this._conf.maxListeners = n;\r\n    }\r\n  };\r\n\r\n  EventEmitter.prototype.event = '';\r\n\r\n  EventEmitter.prototype.once = function(event, fn) {\r\n    this.many(event, 1, fn);\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.many = function(event, ttl, fn) {\r\n    var self = this;\r\n\r\n    if (typeof fn !== 'function') {\r\n      throw new Error('many only accepts instances of Function');\r\n    }\r\n\r\n    function listener() {\r\n      if (--ttl === 0) {\r\n        self.off(event, listener);\r\n      }\r\n      fn.apply(this, arguments);\r\n    }\r\n\r\n    listener._origin = fn;\r\n\r\n    this.on(event, listener);\r\n\r\n    return self;\r\n  };\r\n\r\n  EventEmitter.prototype.emit = function() {\r\n\r\n    this._events || init.call(this);\r\n\r\n    var type = arguments[0];\r\n\r\n    if (type === 'newListener' && !this.newListener) {\r\n      if (!this._events.newListener) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    var al = arguments.length;\r\n    var args,l,i,j;\r\n    var handler;\r\n\r\n    if (this._all && this._all.length) {\r\n      handler = this._all.slice();\r\n      if (al > 3) {\r\n        args = new Array(al);\r\n        for (j = 0; j < al; j++) args[j] = arguments[j];\r\n      }\r\n\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler[i].call(this, type);\r\n          break;\r\n        case 2:\r\n          handler[i].call(this, type, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler[i].call(this, type, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          handler[i].apply(this, args);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.wildcard) {\r\n      handler = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\r\n    } else {\r\n      handler = this._events[type];\r\n      if (typeof handler === 'function') {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler.call(this);\r\n          break;\r\n        case 2:\r\n          handler.call(this, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler.call(this, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          args = new Array(al - 1);\r\n          for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n          handler.apply(this, args);\r\n        }\r\n        return true;\r\n      } else if (handler) {\r\n        // need to make copy of handlers because list can change in the middle\r\n        // of emit call\r\n        handler = handler.slice();\r\n      }\r\n    }\r\n\r\n    if (handler && handler.length) {\r\n      if (al > 3) {\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n      }\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler[i].call(this);\r\n          break;\r\n        case 2:\r\n          handler[i].call(this, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler[i].call(this, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          handler[i].apply(this, args);\r\n        }\r\n      }\r\n      return true;\r\n    } else if (!this._all && type === 'error') {\r\n      if (arguments[1] instanceof Error) {\r\n        throw arguments[1]; // Unhandled 'error' event\r\n      } else {\r\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\r\n      }\r\n      return false;\r\n    }\r\n\r\n    return !!this._all;\r\n  };\r\n\r\n  EventEmitter.prototype.emitAsync = function() {\r\n\r\n    this._events || init.call(this);\r\n\r\n    var type = arguments[0];\r\n\r\n    if (type === 'newListener' && !this.newListener) {\r\n        if (!this._events.newListener) { return Promise.resolve([false]); }\r\n    }\r\n\r\n    var promises= [];\r\n\r\n    var al = arguments.length;\r\n    var args,l,i,j;\r\n    var handler;\r\n\r\n    if (this._all) {\r\n      if (al > 3) {\r\n        args = new Array(al);\r\n        for (j = 1; j < al; j++) args[j] = arguments[j];\r\n      }\r\n      for (i = 0, l = this._all.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          promises.push(this._all[i].call(this, type));\r\n          break;\r\n        case 2:\r\n          promises.push(this._all[i].call(this, type, arguments[1]));\r\n          break;\r\n        case 3:\r\n          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));\r\n          break;\r\n        default:\r\n          promises.push(this._all[i].apply(this, args));\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.wildcard) {\r\n      handler = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\r\n    } else {\r\n      handler = this._events[type];\r\n    }\r\n\r\n    if (typeof handler === 'function') {\r\n      this.event = type;\r\n      switch (al) {\r\n      case 1:\r\n        promises.push(handler.call(this));\r\n        break;\r\n      case 2:\r\n        promises.push(handler.call(this, arguments[1]));\r\n        break;\r\n      case 3:\r\n        promises.push(handler.call(this, arguments[1], arguments[2]));\r\n        break;\r\n      default:\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n        promises.push(handler.apply(this, args));\r\n      }\r\n    } else if (handler && handler.length) {\r\n      if (al > 3) {\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n      }\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          promises.push(handler[i].call(this));\r\n          break;\r\n        case 2:\r\n          promises.push(handler[i].call(this, arguments[1]));\r\n          break;\r\n        case 3:\r\n          promises.push(handler[i].call(this, arguments[1], arguments[2]));\r\n          break;\r\n        default:\r\n          promises.push(handler[i].apply(this, args));\r\n        }\r\n      }\r\n    } else if (!this._all && type === 'error') {\r\n      if (arguments[1] instanceof Error) {\r\n        return Promise.reject(arguments[1]); // Unhandled 'error' event\r\n      } else {\r\n        return Promise.reject(\"Uncaught, unspecified 'error' event.\");\r\n      }\r\n    }\r\n\r\n    return Promise.all(promises);\r\n  };\r\n\r\n  EventEmitter.prototype.on = function(type, listener) {\r\n    if (typeof type === 'function') {\r\n      this.onAny(type);\r\n      return this;\r\n    }\r\n\r\n    if (typeof listener !== 'function') {\r\n      throw new Error('on only accepts instances of Function');\r\n    }\r\n    this._events || init.call(this);\r\n\r\n    // To avoid recursion in the case that type == \"newListeners\"! Before\r\n    // adding it to the listeners, first emit \"newListeners\".\r\n    this.emit('newListener', type, listener);\r\n\r\n    if (this.wildcard) {\r\n      growListenerTree.call(this, type, listener);\r\n      return this;\r\n    }\r\n\r\n    if (!this._events[type]) {\r\n      // Optimize the case of one listener. Don't need the extra array object.\r\n      this._events[type] = listener;\r\n    }\r\n    else {\r\n      if (typeof this._events[type] === 'function') {\r\n        // Change to array.\r\n        this._events[type] = [this._events[type]];\r\n      }\r\n\r\n      // If we've already got an array, just append.\r\n      this._events[type].push(listener);\r\n\r\n      // Check for listener leak\r\n      if (\r\n        !this._events[type].warned &&\r\n        this._events.maxListeners > 0 &&\r\n        this._events[type].length > this._events.maxListeners\r\n      ) {\r\n        this._events[type].warned = true;\r\n        logPossibleMemoryLeak.call(this, this._events[type].length, type);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.onAny = function(fn) {\r\n    if (typeof fn !== 'function') {\r\n      throw new Error('onAny only accepts instances of Function');\r\n    }\r\n\r\n    if (!this._all) {\r\n      this._all = [];\r\n    }\r\n\r\n    // Add the function to the event listener collection.\r\n    this._all.push(fn);\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\r\n\r\n  EventEmitter.prototype.off = function(type, listener) {\r\n    if (typeof listener !== 'function') {\r\n      throw new Error('removeListener only takes instances of Function');\r\n    }\r\n\r\n    var handlers,leafs=[];\r\n\r\n    if(this.wildcard) {\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\r\n    }\r\n    else {\r\n      // does not use listeners(), so no side effect of creating _events[type]\r\n      if (!this._events[type]) return this;\r\n      handlers = this._events[type];\r\n      leafs.push({_listeners:handlers});\r\n    }\r\n\r\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\r\n      var leaf = leafs[iLeaf];\r\n      handlers = leaf._listeners;\r\n      if (isArray(handlers)) {\r\n\r\n        var position = -1;\r\n\r\n        for (var i = 0, length = handlers.length; i < length; i++) {\r\n          if (handlers[i] === listener ||\r\n            (handlers[i].listener && handlers[i].listener === listener) ||\r\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\r\n            position = i;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (position < 0) {\r\n          continue;\r\n        }\r\n\r\n        if(this.wildcard) {\r\n          leaf._listeners.splice(position, 1);\r\n        }\r\n        else {\r\n          this._events[type].splice(position, 1);\r\n        }\r\n\r\n        if (handlers.length === 0) {\r\n          if(this.wildcard) {\r\n            delete leaf._listeners;\r\n          }\r\n          else {\r\n            delete this._events[type];\r\n          }\r\n        }\r\n\r\n        this.emit(\"removeListener\", type, listener);\r\n\r\n        return this;\r\n      }\r\n      else if (handlers === listener ||\r\n        (handlers.listener && handlers.listener === listener) ||\r\n        (handlers._origin && handlers._origin === listener)) {\r\n        if(this.wildcard) {\r\n          delete leaf._listeners;\r\n        }\r\n        else {\r\n          delete this._events[type];\r\n        }\r\n\r\n        this.emit(\"removeListener\", type, listener);\r\n      }\r\n    }\r\n\r\n    function recursivelyGarbageCollect(root) {\r\n      if (root === undefined) {\r\n        return;\r\n      }\r\n      var keys = Object.keys(root);\r\n      for (var i in keys) {\r\n        var key = keys[i];\r\n        var obj = root[key];\r\n        if ((obj instanceof Function) || (typeof obj !== \"object\") || (obj === null))\r\n          continue;\r\n        if (Object.keys(obj).length > 0) {\r\n          recursivelyGarbageCollect(root[key]);\r\n        }\r\n        if (Object.keys(obj).length === 0) {\r\n          delete root[key];\r\n        }\r\n      }\r\n    }\r\n    recursivelyGarbageCollect(this.listenerTree);\r\n\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.offAny = function(fn) {\r\n    var i = 0, l = 0, fns;\r\n    if (fn && this._all && this._all.length > 0) {\r\n      fns = this._all;\r\n      for(i = 0, l = fns.length; i < l; i++) {\r\n        if(fn === fns[i]) {\r\n          fns.splice(i, 1);\r\n          this.emit(\"removeListenerAny\", fn);\r\n          return this;\r\n        }\r\n      }\r\n    } else {\r\n      fns = this._all;\r\n      for(i = 0, l = fns.length; i < l; i++)\r\n        this.emit(\"removeListenerAny\", fns[i]);\r\n      this._all = [];\r\n    }\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\r\n\r\n  EventEmitter.prototype.removeAllListeners = function(type) {\r\n    if (arguments.length === 0) {\r\n      !this._events || init.call(this);\r\n      return this;\r\n    }\r\n\r\n    if (this.wildcard) {\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\r\n\r\n      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\r\n        var leaf = leafs[iLeaf];\r\n        leaf._listeners = null;\r\n      }\r\n    }\r\n    else if (this._events) {\r\n      this._events[type] = null;\r\n    }\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.listeners = function(type) {\r\n    if (this.wildcard) {\r\n      var handlers = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\r\n      return handlers;\r\n    }\r\n\r\n    this._events || init.call(this);\r\n\r\n    if (!this._events[type]) this._events[type] = [];\r\n    if (!isArray(this._events[type])) {\r\n      this._events[type] = [this._events[type]];\r\n    }\r\n    return this._events[type];\r\n  };\r\n\r\n  EventEmitter.prototype.listenerCount = function(type) {\r\n    return this.listeners(type).length;\r\n  };\r\n\r\n  EventEmitter.prototype.listenersAny = function() {\r\n\r\n    if(this._all) {\r\n      return this._all;\r\n    }\r\n    else {\r\n      return [];\r\n    }\r\n\r\n  };\r\n\r\n  if (typeof define === 'function' && define.amd) {\r\n     // AMD. Register as an anonymous module.\r\n    define(function() {\r\n      return EventEmitter;\r\n    });\r\n  } else if (typeof exports === 'object') {\r\n    // CommonJS\r\n    module.exports = EventEmitter;\r\n  }\r\n  else {\r\n    // Browser global.\r\n    window.EventEmitter2 = EventEmitter;\r\n  }\r\n}();\r\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","// Generated by CoffeeScript 1.7.1\n(function() {\n  var getNanoSeconds, hrtime, loadTime;\n\n  if ((typeof performance !== \"undefined\" && performance !== null) && performance.now) {\n    module.exports = function() {\n      return performance.now();\n    };\n  } else if ((typeof process !== \"undefined\" && process !== null) && process.hrtime) {\n    module.exports = function() {\n      return (getNanoSeconds() - loadTime) / 1e6;\n    };\n    hrtime = process.hrtime;\n    getNanoSeconds = function() {\n      var hr;\n      hr = hrtime();\n      return hr[0] * 1e9 + hr[1];\n    };\n    loadTime = getNanoSeconds();\n  } else if (Date.now) {\n    module.exports = function() {\n      return Date.now() - loadTime;\n    };\n    loadTime = Date.now();\n  } else {\n    module.exports = function() {\n      return new Date().getTime() - loadTime;\n    };\n    loadTime = new Date().getTime();\n  }\n\n}).call(this);\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","var now = require('performance-now')\n  , root = typeof window === 'undefined' ? global : window\n  , vendors = ['moz', 'webkit']\n  , suffix = 'AnimationFrame'\n  , raf = root['request' + suffix]\n  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]\n\nfor(var i = 0; !raf && i < vendors.length; i++) {\n  raf = root[vendors[i] + 'Request' + suffix]\n  caf = root[vendors[i] + 'Cancel' + suffix]\n      || root[vendors[i] + 'CancelRequest' + suffix]\n}\n\n// Some versions of FF have rAF but not cAF\nif(!raf || !caf) {\n  var last = 0\n    , id = 0\n    , queue = []\n    , frameDuration = 1000 / 60\n\n  raf = function(callback) {\n    if(queue.length === 0) {\n      var _now = now()\n        , next = Math.max(0, frameDuration - (_now - last))\n      last = next + _now\n      setTimeout(function() {\n        var cp = queue.slice(0)\n        // Clear queue here to prevent\n        // callbacks from appending listeners\n        // to the current frame's queue\n        queue.length = 0\n        for(var i = 0; i < cp.length; i++) {\n          if(!cp[i].cancelled) {\n            try{\n              cp[i].callback(last)\n            } catch(e) {\n              setTimeout(function() { throw e }, 0)\n            }\n          }\n        }\n      }, Math.round(next))\n    }\n    queue.push({\n      handle: ++id,\n      callback: callback,\n      cancelled: false\n    })\n    return id\n  }\n\n  caf = function(handle) {\n    for(var i = 0; i < queue.length; i++) {\n      if(queue[i].handle === handle) {\n        queue[i].cancelled = true\n      }\n    }\n  }\n}\n\nmodule.exports = function(fn) {\n  // Wrap in a new function to prevent\n  // `cancel` potentially being assigned\n  // to the native rAF function\n  return raf.call(root, fn)\n}\nmodule.exports.cancel = function() {\n  caf.apply(root, arguments)\n}\nmodule.exports.polyfill = function(object) {\n  if (!object) {\n    object = root;\n  }\n  object.requestAnimationFrame = raf\n  object.cancelAnimationFrame = caf\n}\n","var Emitter = require('eventemitter2').EventEmitter2\nvar now = require('performance-now')\nvar inherits = require('inherits')\nvar raf = require('raf')\n\nmodule.exports = Game\ninherits(Game, Emitter)\n\n/**\n* Create the game\n* @name createGame\n* @param {Object} options\n* @param {Object} options.renderer\n* @param {Number} options.fps\n* @example\n* var createGame = require('gameloop')\n*\n* var game = createGame({\n*   renderer: document.createElement('canvas').getContext('2d')\n* })\n*/\nfunction Game (options) {\n  if (!(this instanceof Game)) return new Game(options)\n  options = options || {}\n  Emitter.call(this)\n  this.paused = true\n  this.renderer = options.renderer || {}\n  this.fps = options.fps || 60\n  this.step = 1 / this.fps\n}\n\n/**\n* Start the game. Emits the `start` event.\n* @name game.start\n* @fires Game#start\n* @param {Object} state – arbitrary starting game state emitted by `start` event.\n* @example\n* game.start()\n*/\nGame.prototype.start = function start (state) {\n  this.paused = false\n  this.last = now()\n  this.time = 0\n  this.accumulator = 0\n  this.emit('start', state)\n  raf(this.frame.bind(this))\n}\n\n/**\n* Execute a frame\n* @name game.frame\n* @private\n*/\nGame.prototype.frame = function frame (time) {\n  if (!this.paused) {\n    var newTime = now()\n    var dt = (newTime - this.last) / 1000\n    if (dt > 0.2) dt = this.step\n    this.accumulator += dt\n    this.last = newTime\n\n    while (this.accumulator >= this.step) {\n      this.time += this.step\n      this.accumulator -= this.step\n      this.update(this.step, this.time)\n    }\n\n    this.draw(this.renderer, this.accumulator / this.step)\n    raf(this.frame.bind(this))\n  }\n}\n\n/**\n* Update the game state. Emits the `update` event. You'll likely never call this method, but you may need to override it. Make sure to always emit the update event with the `delta` time.\n* @name game.update\n* @param {Number} interval – interval between each frame\n* @param {Number} time – total time elapsed\n* @fires Game#update\n*/\nGame.prototype.update = function update (interval, time) {\n  this.emit('update', interval, time)\n}\n\n/**\n* Draw the game. Emits the `draw` event. You'll likely never call this method, but you may need to override it. Make sure to always emit the update event with the renderer and `delta` time.\n* @name game.draw\n* @param {Object} renderer\n* @param {Number} deltaTime – time remaining until game.update is called\n* @fires Game#draw\n*/\nGame.prototype.draw = function draw (renderer, frameState) {\n  this.emit('draw', renderer, frameState)\n}\n\n/**\n* End the game. Emits the `end` event/\n* @name game.end\n* @param {Object} state – state of end game conditions\n* @fires Game#end\n* @example\n* game.end()\n*/\nGame.prototype.end = function end (state) {\n  this.emit('end', state)\n}\n\n/**\n* Pause the game. Emits the `pause` event.\n* @name game.pause\n* @fires Game#pause\n* @example\n* game.pause()\n*/\nGame.prototype.pause = function pause () {\n  if (!this.paused) {\n    this.paused = true\n    this.emit('pause')\n  }\n}\n\n/**\n* Resume the game. Emits the `resume` event.\n* @name game.resume\n* @fires Game#resume\n* @example\n* game.resume()\n*/\nGame.prototype.resume = function resume () {\n  if (this.paused) {\n    this.start()\n    this.emit('resume')\n  }\n}\n\n/**\n* Pause or start game depending on game state. Emits either the `pause` or `resume` event.\n* @name game.toggle\n* @example\n* game.toggle()\n*/\nGame.prototype.toggle = function toggle () {\n  if (this.paused) this.resume()\n  else this.pause()\n}\n\n/* Event documentation */\n\n/**\n* Start event. Fired when `game.start()` is called.\n*\n* @event Game#start\n* @example\n* game.on('start', function () {})\n*/\n\n/**\n* End event. Fired when `game.end()` is called.\n*\n* @event Game#end\n* @param {Object} state - state of end game conditions\n* @example\n* game.on('end', function (state) {})\n*/\n\n/**\n* Update event.\n*\n* @event Game#update\n* @param {Number} interval – interval between each frame\n* @param {Number} frameState – current state of the completion of the frame\n* @param {Number} time – total time elapsed\n* @example\n* game.on('update', function (interval, time) {\n*   console.log(interval)\n* })\n*/\n\n/**\n* Draw event.\n*\n* @event Game#draw\n* @param {Number} frameState – current state of the completion of the frame\n* @param {Number} delta\n* @example\n* game.on('draw', function (renderer, dt) {\n*   console.log(dt)\n* })\n*/\n\n/**\n* Pause event. Fired when `game.pause()` is called.\n*\n* @event Game#pause\n* @example\n* game.on('pause', function () {})\n*/\n\n/**\n* Resume event. Fired when `game.resume()` is called.\n*\n* @event Game#resume\n* @example\n* game.on('resume', function () {})\n*/\n","var GameLoop = require('gameloop')\n\nmodule.exports = function (options) {\n  options || (options = {})\n  var canvas\n\n  if (!options.canvas) {\n    canvas = document.createElement('canvas')\n    canvas.id = 'game'\n    document.body.appendChild(canvas)\n  } else if (typeof options.canvas === 'string') {\n    canvas = document.getElementById(options.canvas)\n  } else if (typeof options.canvas === 'object' && options.canvas.tagName) {\n    canvas = options.canvas\n  }\n\n  var game = new GameLoop({\n    renderer: canvas.getContext('2d')\n  })\n\n  game.canvas = canvas\n  game.width = canvas.width = options.width || 1024\n  game.height = canvas.height = options.height || 480\n\n  return game\n}\n","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n","var createGameLoop = require('gameloop-canvas')\nvar isarray = require('isarray')\n\n/**\n* Create the game\n* @name createGame\n* @extends module:gameloop-canvas\n* @param {Object} options\n* @param {Object} [options.canvas] – id or dom node of canvas tag\n* @param {Number} [options.fps]\n* @example\n* var createGame = require('crtrdg-gameloop')\n*\n* var game = createGame({ canvas: 'game' })\n*/\nmodule.exports = function createGame (options) {\n  options = options || {}\n  var game = createGameLoop(options)\n\n  /**\n  * Draw to the canvas\n  * @name game.draw\n  * @param {Object} renderer\n  * @param {Number} delta – time elapsed since last update\n  * @fires Game#draw\n  */\n  game.draw = function crtrdg_gameloop_draw (context, delta) {\n    context.clearRect(0, 0, game.width, game.height)\n    game.emit('draw-background', context, delta)\n    game.drawAllLayers(context, delta)\n    game.emit('draw-foreground', context, delta)\n  }\n\n  game.drawAllLayers = function crtrdg_gameloop_drawAllLayers (context, dt) {\n    if (game.layers && isarray(game.layers)) {\n      for (var i = 0; i < game.layers.length; i++) {\n        game.emit('draw-layer', game.layers[i], context, dt)\n\n        if (game.layers[i] === 0) {\n          game.emit('draw', context, dt)\n        }\n      }\n    } else {\n      game.emit('draw', context, dt)\n    }\n  }\n\n  return game\n}\n\n/* gameloop documentation */\n\n/**\n* Update the game state. Emits the `update` event. You'll likely never call this method, but you may need to override it. Make sure to always emit the update event with the `delta` time.\n* @name game.update\n* @param {Number} delta – time elapsed since last update\n* @fires Game#update\n*/\n\n/**\n* End the game. Emits the `end` event/\n* @name game.end\n* @fires Game#end\n* @example\n* game.end()\n*/\n\n/**\n* Pause or start game depending on game state. Emits either the `pause` or `resume` event.\n* @name game.toggle\n* @example\n* game.toggle()\n*/\n\n/**\n* Resume the game. Emits the `resume` event.\n* @name game.resume\n* @fires Game#resume\n* @example\n* game.resume()\n*/\n\n/* gameloop events */\n\n/**\n* Start event. Fired when `game.start()` is called.\n*\n* @event Game#start\n* @example\n* game.on('start', function () {})\n*/\n\n/**\n* End event. Fired when `game.end()` is called.\n*\n* @event Game#end\n* @example\n* game.on('end', function () {})\n*/\n\n/**\n* Update event.\n*\n* @event Game#update\n* @param {Number} delta\n* @example\n* game.on('update', function (dt) {\n*   console.log(dt)\n* })\n*/\n\n/**\n* Draw event.\n*\n* @event Game#draw\n* @param {Object} renderer\n* @param {Number} delta\n* @example\n* game.on('draw', function (renderer, dt) {\n*   console.log(dt)\n* })\n*/\n\n/**\n* Pause event. Fired when `game.pause()` is called.\n*\n* @event Game#pause\n* @example\n* game.on('pause', function () {})\n*/\n\n/**\n* Resume event. Fired when `game.resume()` is called.\n*\n* @event Game#resume\n* @example\n* game.on('resume', function () {})\n*/\n\n","import createGame from 'crtrdg-gameloop'\n\nconst game = createGame()\n\ngame.canvas.height = 512\ngame.canvas.width = 512\n\nconst tileset = new Image(512, 512); // Using optional size for image\ntileset.src = 'https://cdn.glitch.com/8804483f-7435-434d-ab8d-d8d811696a6a%2F0x72_DungeonTilesetII_v1.3.png?v=1586091258409'\n\n\n// ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n\n\n\ngame.on('draw', function (ctx, dt) {\n  // ctx.drawImage(tileset, 0, 0, 16, 16, 0, 0, 16, 16)\n  ctx.fillStyle = \"#222\"\n  ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n  ctx.drawImage(tileset, 16, 64, 16, 16, 0, 0, 16, 16)\n})\n\n\ngame.start()\n"]}